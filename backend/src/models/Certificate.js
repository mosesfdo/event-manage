import mongoose from 'mongoose'
import crypto from 'crypto'

const certificateSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'User ID is required']
  },
  eventId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Event',
    required: [true, 'Event ID is required']
  },
  attendanceId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Attendance',
    required: [true, 'Attendance ID is required']
  },
  
  // Certificate Details
  certificateId: {
    type: String,
    unique: true,
    required: [true, 'Certificate ID is required']
  },
  recipientName: {
    type: String,
    required: [true, 'Recipient name is required'],
    trim: true
  },
  eventTitle: {
    type: String,
    required: [true, 'Event title is required'],
    trim: true
  },
  clubName: {
    type: String,
    required: [true, 'Club name is required'],
    trim: true
  },
  eventDate: {
    type: Date,
    required: [true, 'Event date is required']
  },
  
  // File & Verification
  pdfUrl: {
    type: String,
    required: [true, 'PDF URL is required']
  },
  qrCodeData: {
    type: String,
    required: [true, 'QR code data is required']
  },
  verificationUrl: {
    type: String,
    required: [true, 'Verification URL is required']
  },
  
  // Status
  isRevoked: {
    type: Boolean,
    default: false
  },
  revokedAt: {
    type: Date,
    default: null
  },
  revokedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null
  },
  revokeReason: {
    type: String,
    default: null
  },
  
  // Generation Details
  generatedAt: {
    type: Date,
    default: Date.now
  },
  generatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Generated by user ID is required']
  },
  template: {
    type: String,
    default: 'default',
    enum: ['default', 'academic', 'cultural', 'sports', 'technical']
  },
  
  // Additional metadata
  metadata: {
    fileSize: Number,
    generationTime: Number, // milliseconds
    version: {
      type: String,
      default: '1.0'
    }
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
})

// Indexes
certificateSchema.index({ certificateId: 1 }, { unique: true })
certificateSchema.index({ userId: 1, generatedAt: -1 })
certificateSchema.index({ eventId: 1, generatedAt: -1 })
certificateSchema.index({ isRevoked: 1 })
certificateSchema.index({ generatedAt: -1 })

// Virtual populate for user
certificateSchema.virtual('user', {
  ref: 'User',
  localField: 'userId',
  foreignField: '_id',
  justOne: true
})

// Virtual populate for event
certificateSchema.virtual('event', {
  ref: 'Event',
  localField: 'eventId',
  foreignField: '_id',
  justOne: true
})

// Virtual populate for attendance
certificateSchema.virtual('attendance', {
  ref: 'Attendance',
  localField: 'attendanceId',
  foreignField: '_id',
  justOne: true
})

// Virtual for certificate status
certificateSchema.virtual('status').get(function() {
  if (this.isRevoked) return 'revoked'
  return 'valid'
})

// Pre-save middleware to generate certificate ID
certificateSchema.pre('save', function(next) {
  if (!this.certificateId) {
    // Generate unique certificate ID: CERT-YYYY-XXXXXXXX
    const year = new Date().getFullYear()
    const randomId = crypto.randomBytes(4).toString('hex').toUpperCase()
    this.certificateId = `CERT-${year}-${randomId}`
  }
  
  // Generate verification URL
  if (!this.verificationUrl) {
    this.verificationUrl = `${process.env.FRONTEND_URL}/certificate/verify/${this.certificateId}`
  }
  
  // Generate QR code data for verification
  if (!this.qrCodeData) {
    this.qrCodeData = JSON.stringify({
      certificateId: this.certificateId,
      recipientName: this.recipientName,
      eventTitle: this.eventTitle,
      eventDate: this.eventDate,
      verificationUrl: this.verificationUrl
    })
  }
  
  next()
})

// Pre-save validation
certificateSchema.pre('save', async function(next) {
  try {
    // Verify that user attended the event
    const Attendance = mongoose.model('Attendance')
    const attendance = await Attendance.findOne({
      userId: this.userId,
      eventId: this.eventId
    })
    
    if (!attendance) {
      throw new Error('User must have attended the event to receive a certificate')
    }
    
    // Set attendance ID if not provided
    if (!this.attendanceId) {
      this.attendanceId = attendance._id
    }
    
    // Verify event is completed
    const Event = mongoose.model('Event')
    const event = await Event.findById(this.eventId)
    
    if (!event) {
      throw new Error('Event not found')
    }
    
    if (event.status !== 'completed' && new Date() < event.endTime) {
      throw new Error('Certificates can only be generated for completed events')
    }
    
    next()
  } catch (error) {
    next(error)
  }
})

// Static methods
certificateSchema.statics.findByUser = function(userId, filter = {}) {
  return this.find({ 
    ...filter, 
    userId: userId,
    isRevoked: false 
  }).populate('event')
}

certificateSchema.statics.findByEvent = function(eventId, filter = {}) {
  return this.find({ 
    ...filter, 
    eventId: eventId 
  }).populate('user')
}

certificateSchema.statics.findByCertificateId = function(certificateId) {
  return this.findOne({ 
    certificateId: certificateId 
  }).populate(['user', 'event', 'attendance'])
}

certificateSchema.statics.verifyCertificate = async function(certificateId) {
  const certificate = await this.findByCertificateId(certificateId)
  
  if (!certificate) {
    return {
      isValid: false,
      error: 'Certificate not found'
    }
  }
  
  if (certificate.isRevoked) {
    return {
      isValid: false,
      error: 'Certificate has been revoked',
      revokeReason: certificate.revokeReason,
      revokedAt: certificate.revokedAt
    }
  }
  
  return {
    isValid: true,
    certificate: {
      certificateId: certificate.certificateId,
      recipientName: certificate.recipientName,
      eventTitle: certificate.eventTitle,
      clubName: certificate.clubName,
      eventDate: certificate.eventDate,
      generatedAt: certificate.generatedAt
    }
  }
}

certificateSchema.statics.generateForEvent = async function(eventId, generatedBy) {
  const Attendance = mongoose.model('Attendance')
  const Event = mongoose.model('Event')
  const User = mongoose.model('User')
  const Club = mongoose.model('Club')
  
  // Get event details
  const event = await Event.findById(eventId).populate('club')
  if (!event) {
    throw new Error('Event not found')
  }
  
  // Get all attendees
  const attendances = await Attendance.find({ eventId: eventId }).populate('user')
  
  const certificates = []
  
  for (const attendance of attendances) {
    // Check if certificate already exists
    const existingCert = await this.findOne({
      userId: attendance.userId,
      eventId: eventId
    })
    
    if (existingCert) {
      continue // Skip if certificate already exists
    }
    
    // Create certificate
    const certificate = new this({
      userId: attendance.userId,
      eventId: eventId,
      attendanceId: attendance._id,
      recipientName: attendance.user.fullName,
      eventTitle: event.title,
      clubName: event.club.name,
      eventDate: event.date,
      generatedBy: generatedBy,
      template: event.category || 'default'
    })
    
    await certificate.save()
    certificates.push(certificate)
  }
  
  return certificates
}

// Instance methods
certificateSchema.methods.revoke = async function(revokedBy, reason = null) {
  this.isRevoked = true
  this.revokedAt = new Date()
  this.revokedBy = revokedBy
  this.revokeReason = reason
  
  await this.save()
  return this
}

certificateSchema.methods.canRevoke = function() {
  return !this.isRevoked
}

certificateSchema.methods.generatePDF = async function() {
  // This method would integrate with PDF generation service
  // For now, return a placeholder URL
  const pdfUrl = `${process.env.API_URL}/certificates/${this.certificateId}/download`
  
  this.pdfUrl = pdfUrl
  await this.save()
  
  return pdfUrl
}

const Certificate = mongoose.model('Certificate', certificateSchema)

export default Certificate